x_newt <- Newton(fun, df, x0 = -5)
x_newt <- Newton(fun, df, x0 = -5)
x_bisect <- Bisection(fun, -5, 5)
opt_quad <- function(f, a, b, c, tol=1e-3,N=10){
## Initialize variables
an <- a
bn <- b
cn <- c
xn <- median(an, bn, cn)
xn_1 <- 0 ## x (n - 1)
fa <- f(a)
fb <- f(b)
fc <- f(c)
i <- 1
outstats <- tibble(iter = i,
a = an, b = bn, c = cn,
x = xn, f_x = f(xn))
while(abs(bn - xn) > tol | i < N){
fx <- f(xn)
l <- min(xn, xn_1)
r <- max(xn, xn_1)
if(f(r) < f(l)){
an <- l
bn <- r
cn <- c
}
else{
an <- a
bn <- l
cn <- r
}
xn <- median(an, bn, cn)
i <- i + 1
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
}
return(outstats)
}
opt_quad(f, a = 2, b = 3.25, c = 4.5)
## Define Original Function
f <- function(x){
fx <- x + 16*(x + 1)^(-1)
return(fx)
}
## Define Derivative Function
df <- function(x){
dfx <- 1 - 16*(x + 1)^(-2)
return(dfx)
}
opt_quad(f, a = 2, b = 3.25, c = 4.5)
library(tidyverse)
opt_quad(f, a = 2, b = 3.25, c = 4.5)
install.packages('tidyverse')
install.packages("tibble")
library(tibble)
opt_quad(f, a = 2, b = 3.25, c = 4.5)
opt_quad <- function(f, a, b, c, tol=1e-3,N=10){
## Initialize variables
an <- a
bn <- b
cn <- c
xn <- median(an, bn, cn)
xn_1 <- 0 ## x (n - 1)
fa <- f(a)
fb <- f(b)
fc <- f(c)
i <- 1
outstats <- tibble(iter = i,
a = an, b = bn, c = cn,
x = xn, f_x = f(xn))
while(abs(bn - xn) > tol | i < N){
fx <- f(xn)
l <- min(xn, xn_1)
r <- max(xn, xn_1)
if(f(r) < f(l)){
an <- l
bn <- r
cn <- c
}
else{
an <- a
bn <- l
cn <- r
}
xn <- median(an, bn, cn)
print(xn)
i <- i + 1
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
}
return(outstats)
}
library(tibble)
opt_quad(f, a = 2, b = 3.25, c = 4.5)
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
while(abs(bn - xn) > tol | i < N){
l <- min(xn, xn_1)
r <- max(xn, xn_1)
xn_1 <- xn
if(f(r) < f(l)){
an <- l
bn <- r
cn <- c
}
else{
an <- a
bn <- l
cn <- r
}
xn <- median(an, bn, cn)
print(xn)
i <- i + 1
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
}
return(outstats)
opt_quad <- function(f, a, b, c, tol=1e-3,N=10){
## Initialize variables
an <- a
bn <- b
cn <- c
xn <- median(an, bn, cn)
xn_1 <- 0 ## x (n - 1)
fa <- f(a)
fb <- f(b)
fc <- f(c)
i <- 1
outstats <- tibble(iter = i,
a = an, b = bn, c = cn,
x = xn, f_x = f(xn))
while(abs(bn - xn) > tol | i < N){
l <- min(xn, xn_1)
r <- max(xn, xn_1)
xn_1 <- xn
if(f(r) < f(l)){
an <- l
bn <- r
cn <- c
}
else{
an <- a
bn <- l
cn <- r
}
xn <- median(an, bn, cn)
print(xn)
i <- i + 1
outstats <- outstats %>%
add_row(
iter = i,
a = an, b = bn, c = cn, x = xn, f_x = f(xn)
)
}
return(outstats)
}
library(tibble)
opt_quad(f, a = 2, b = 3.25, c = 4.5)
library(tidyverse)
install.packages('tidyverse')
library("caret", lib.loc="~/opt/anaconda3/envs/applied_analytics/lib/R/library")
library(tidyverse)
library(caret)
library(caret)
library("caret", lib.loc="~/opt/anaconda3/envs/applied_analytics/lib/R/library")
library(caret)
install.packages('tidyverse')
install.packages('tidyverse')
library("caret", lib.loc="~/opt/anaconda3/envs/applied_analytics/lib/R/library")
library("caret", lib.loc="~/opt/anaconda3/envs/applied_analytics/lib/R/library")
install.packages("tidyverse")
library(quantmod)
library(quantmod)
library(lubridate)
library(tidyverse)
library(plotly)
start =
end = today()
print(start)
DownloadReturns <- function(ticker,
start = lubridate::mdy('01-01-2010'),
end = lubridate::today()
){
## Read in stock data in the given range for the given ticker
## From yahoo finance
df <- getSymbols(ticker, src = 'yahoo', auto.assign = F,
from = '01-01-2010',
to = today() )
## extract the dates
dates <- index(df)
## Rename the columns
names(df) <- c('open', 'high', 'low', 'close', 'volume', 'adjusted')
## Convert to tibble, we only need the date and the index
df <- tibble::as_tibble(df) %>% select(adjusted) %>%
add_column(date = dates, .before = 'adjusted') %>%
## find the lag term, drop the first term since there is no
## lag to the first price
mutate(lag = lag(adjusted)) %>% drop_na() %>%
## Find the returns
mutate(returns = (adjusted - lag) / lag) %>%
## We only care about the date and the returns
select(date, returns)
## Rename the returns so we include the ticker
ret_name = paste(tolower(ticker), 'adjusted', sep = '_')
names(df) <- c('date', ret_name)
return(df)
}
RFRate <- function(start = lubridate::mdy('01-01-2010'),
end = lubridate::today()  ){
## Find the risk free rate for the CAPM
df <- getSymbols('DGS3MO', src = 'FRED', auto.assign = F)
## get dates
dates <- index(df)
df <- tibble::as_tibble(df) %>%
## add dates column
add_column(date = dates) %>%
## Convert from percent to decimal
mutate(rf_rate = DGS3MO / 100) %>% drop_na()
return(df %>% select(date, rf_rate))
}
## List of stocks
stocks <- c('JNJ', 'GME', 'MRNA', 'RTX', 'JPM',
'SPOT', 'PG', 'AMZN', 'SYK', 'BSX')
## Find the start and end dates
from <- mdy('01-01-2010')
to <- today()
## Find the first stock in the array
rets <- DownloadReturns(stocks[1])
for(stock in stocks[2:length(stocks)]){
rets <- rets %>%
inner_join(DownloadReturns(stock, start = from,
end = to))
}
## Add in the Risk Free Rate
rets <- rets %>%
inner_join(RFRate(start = from,
end = to))
library(Matrix)
plot_ly(x = names(rets), y = names(rets),
z = as.matrix(rets), type = 'heatmap')
names(rets)
library(corrplot)
rets %>%
select(-date) %>%
cor()
rets %>%
select(-date) %>%
cor() %>% plot_ly(type = 'heatmap')
plot_ly(z = ret_corrs, type = 'heatmap')
ret_corrs <- rets %>%
select(-date) %>%
cor()
plot_ly(z = ret_corrs, type = 'heatmap')
names(ret_corrs)
ret_corrs
View(ret_corrs)
index(ret_corrs)
ret_corrs <- as.matrix(rets %>%
select(-date) %>%
cor())
plot_ly(x = names(ret_corrs),
y = names(ret_corrs),
z = ret_corrs, type = 'heatmap')
names(ret_corrs)
plot_ly(x = ret_corr_name,
y = ret_corr_name,
z = ret_corrs, type = 'heatmap')
ret_corr_name <- names(rets %>% select(-date))
plot_ly(x = ret_corr_name,
y = ret_corr_name,
z = ret_corrs, type = 'heatmap')
myBMD(M = 1000000, N = 1, d = 2, t = 1, mu = mu, X0 = S0, sigma = sigma, rho = rho)
#### Question 5: ####
myBMD <- function(M, N, d, t, mu, sigma, rho, X0){
## 3d x array for results
X <- array(NA, dim = c(M, N + 1, d))
## Set initial values = 0
X[,1,] <- X0
B <- t(chol(Sigma))
dt <- t / N
sigma <- matrix(sigma, ncol = 1, nrow = d)
muMat <- matrix(rep(mu - 0.5 * sigma * sigma, M), ncol = d, byrow = T)
## Run simulation
for(i in 1:N){
Zmat <- matrix(rnorm(d * M), ncol = M)
X[,i + 1,] <- X[,i,] + muMat * dt + sqrt(dt) * t(B %*% Zmat)
}
return(X)
}
r <- 0.06
t <- 1
mu <- c(1,1)^r
S0 <- 100
K <- 1
sigma <- c(0.2, 0.3)
rho <- matrix(c(1,0.5,0.5,1), ncol = 2)
myBMD(M = 1000000, N = 1, d = 2, t = 1, mu = mu, X0 = S0, sigma = sigma, rho = rho)
diag(sigma) %*% rho %*% diag(sigma)
#### Question 5: ####
myBMD <- function(M, N, d, t, mu, sigma, rho, X0){
## 3d x array for results
X <- array(NA, dim = c(M, N + 1, d))
## Set initial values = 0
X[,1,] <- X0
Sigma <- diag(sigma) %*% rho %*% diag(sigma)
B <- t(chol(Sigma))
dt <- t / N
sigma <- matrix(sigma, ncol = 1, nrow = d)
muMat <- matrix(rep(mu - 0.5 * sigma * sigma, M), ncol = d, byrow = T)
## Run simulation
for(i in 1:N){
Zmat <- matrix(rnorm(d * M), ncol = M)
X[,i + 1,] <- X[,i,] + muMat * dt + sqrt(dt) * t(B %*% Zmat)
}
return(X)
}
r <- 0.06
t <- 1
mu <- c(1,1)^r
S0 <- 100
K <- 1
sigma <- c(0.2, 0.3)
rho <- matrix(c(1,0.5,0.5,1), ncol = 2)
myBMD(M = 1000000, N = 1, d = 2, t = 1, mu = mu, X0 = S0, sigma = sigma, rho = rho)
X <- myBMD(M = 1000000, N = 1, d = 2, t = 1, mu = mu, X0 = S0, sigma = sigma, rho = rho)
## terminal payoff
h <- function(X){
h <- pmax(X[,1] - X[,2] - K,0)
return(h)
}
f0 <- exp(-r * t) * h(X)
X
X[,1]
X[,1,]
## terminal payoff
h <- function(X){
h <- pmax(X[,1,] - X[,2,] - K,0)
return(h)
}
f0 <- exp(-r * t) * h(X)
## terminal payoff
h <- function(X){
h <- pmax(X[,1,] - X[,2,] - K,0)
return(h)
}
f0 <- exp(-r * t) * h(X)
opt <- mean(f0)
opt.sd <- sd(f0)
## 95% interval
z <- qnorm(1 - alpha / 2)
CI <- c(opt - z * opt.sd / set.sqrt(M), opt + z * opt.sd / set.sqrt(M))
## 95% interval
alpha = 0.025
## 95% interval
alpha <- 0.025
z <- qnorm(1 - alpha / 2)
CI <- c(opt - z * opt.sd / set.sqrt(M), opt + z * opt.sd / set.sqrt(M))
CI <- c(opt - z * opt.sd / sqrt(M), opt + z * opt.sd / sqrt(M))
M <- 1000000
CI <- c(opt - z * opt.sd / sqrt(M), opt + z * opt.sd / sqrt(M))
CI
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
n_stocks <- 6
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
mu<- matrix(mean_rets, ncol  = 1)
Sigma <- var(rets %>% select(-Date), use = 'complete.obs')
rho <- cor(rets %>% select(-Date), use = 'complete.obs')
sigma <- var(rets %>% select(-Date), use = 'complete.obs')
M <- 10
N <- 10
d <- n_stocks
t <- 1
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma * 252)
gmd_model$Delta
dim(gmd_model$Delta)
N <- 11
d <- n_stocks
t <- 1
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma * 252)
gmd_model$Delta
dim(gmd_model$Delta)
N <- 13 ## number of time steps
d <- n_stocks
t <- 1
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma * 252)
gmd_model$Delta
dim(gmd_model$Delta)
# Define a function to simulate paths:
myCEVD <- function(M,N,d,t,mu,X0,sigma,rho,alpha){
# Generate 3-dim X array for results:
S.CEV <- deltas <- Z <- array(NA,dim=c(M,N+1,d))
#S.Euler <- array(NA,dim=c(M,N+1,d))
# Set initial values = X0:
S.CEV[,1,] <- X0
Sigma <- diag(sigma)%*%rho%*%diag(sigma)
B <- t(chol(Sigma))
dt <- t/N
muMat <- matrix(rep(mu,M),ncol=d,byrow=T)
# Run the simulation:
for (i in 1:N){
Zmat <- matrix(rnorm(d*M),ncol=M)
# Euler Scheme:
# GBM :
#S.Euler[,i+1,] <- S.Euler[,i,] + mu*S.Euler[,i,]*dt +
#S.Euler[,i,]*sqrt(dt)*t(B%*%Zmat)
# CEV :
S.CEV[,i+1,] <- S.CEV[,i,] + muMat*S.CEV[,i,]*dt +
S.CEV[,i,]^alpha*sqrt(dt)*t(B%*%Zmat)
Z[,i + 1,] <- Z
## Calculate deltas
ttm <- t - dt *(i = 1)
deltas[,i,] <- Delta(S.CEV[,i,], K, 0.05, ttm, diag(sigma))
}
deltas[,N + 1,] <- Delta(S.CEV[,N + 1,], K, 0.05, 0, diag(sigma))
return(list('X' = S.CEV, 'Z' = Z, 'Deltas' = deltas))
}
X <- myCEVD(M,N,d,t,mu,X0,sigma,rho,alpha)
alpha <- 0.8
X <- myCEVD(M,N,d,t,mu,X0,sigma,rho,alpha)
X <- myCEVD(M,N,d,t,mu,X0,Sigma,rho,alpha)
Sigma
rho
diag(Sigma)
X <- myCEVD(M,N,d,t,mu,X0,Sigma,rho,alpha)
# Define a function to simulate paths:
myCEVD <- function(M,N,d,t,mu,X0,sigma,rho,alpha){
# Generate 3-dim X array for results:
S.CEV <- deltas <- Z <- array(NA,dim=c(M,N+1,d))
#S.Euler <- array(NA,dim=c(M,N+1,d))
# Set initial values = X0:
S.CEV[,1,] <- X0
Sigma <- diag(sigma)%*%rho%*%diag(sigma)
B <- t(chol(Sigma))
dt <- t/N
muMat <- matrix(rep(mu,M),ncol=d,byrow=T)
# Run the simulation:
for (i in 1:N){
Zmat <- matrix(rnorm(d*M),ncol=M)
dim(Zmat)
dim(B)
# Euler Scheme:
# GBM :
#S.Euler[,i+1,] <- S.Euler[,i,] + mu*S.Euler[,i,]*dt +
#S.Euler[,i,]*sqrt(dt)*t(B%*%Zmat)
# CEV :
S.CEV[,i+1,] <- S.CEV[,i,] + muMat*S.CEV[,i,]*dt +
S.CEV[,i,]^alpha*sqrt(dt)*t(B%*%Zmat)
Z[,i + 1,] <- Z
## Calculate deltas
ttm <- t - dt *(i = 1)
deltas[,i,] <- Delta(S.CEV[,i,], K, 0.05, ttm, diag(sigma))
}
deltas[,N + 1,] <- Delta(S.CEV[,N + 1,], K, 0.05, 0, diag(sigma))
return(list('X' = S.CEV, 'Z' = Z, 'Deltas' = deltas))
}
X <- myCEVD(M,N,d,t,mu,X0,Sigma,rho,alpha)
X <- myCEVD(M,N,d,t,mu,X0,Sigma,rho,alpha)
X <- myCEVD(M,N,d,t,mu,X0,Sigma,rho,alpha)
