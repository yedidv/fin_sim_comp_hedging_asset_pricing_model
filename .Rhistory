CF <- matrix(NA, ncol = N + 1, nrow = M)
CF[,1] <- -deltas[,1] * X0
for(i in 1:(N - 1)){
CF[,i + 1] <- -1 * (deltas[,i + 1] - deltas[,i]) * stock[,i + 1]
}
IN <- which(stock[,N + 1] > K)
CF[IN, N + 1] <- K - (1 - deltas[IN, N]) * stock[IN, N + 1]
CF[-IN,N+1] <- deltas[-IN,N]*stock[-IN,N+1]
## sum the cost
disc <- matrix(exp(-0.05 * seq(0, t, length = N + 1)), ncol = 1)
PV <- CF %*% disc
PV
bls <- BLS(M, N, X0, K, 0.05, diag(Sigma), t, mu)
sqrt(var(PV)) / bls
PV <- c(CF %*% disc)
PV
bls <- BLS(M, N, X0, K, 0.05, diag(Sigma), t, mu)
sqrt(var(PV)) / bls
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
mu<- matrix(mean_rets, ncol  = 1)
Sigma <- var(rets %>% select(-Date), use = 'complete.obs')
rho <- cor(rets %>% select(-Date), use = 'complete.obs')
sigma <- var(rets %>% select(-Date), use = 'complete.obs')
M <- 5 ## Number of paths
N <- 7 ## number of time steps
d <- n_stocks
t <- 1
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Brownian Motion model.
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma)
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*S0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
# compute performace
H.perf <- sqrt(var(PV))/BLS
print(H.perf)
## Brownian Motion model.
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma)
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*S0
CF[,1] <- -deltas[,1]*X0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
r <- 0.05
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*X0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
# compute performace
H.perf <- sqrt(var(PV))/BLS
bls <- 7
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
bls <- BLS(M, N, X0, K, r, diag(Sigma, t, mu)
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
bls <- BLS(M, N, X0, K, r, diag(Sigma, t, mu) )
bls <- BLS(M, N, X0, K, r, diag(Sigma), t, mu )
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
bls
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
mu<- matrix(mean_rets, ncol  = 1)
Sigma <- var(rets %>% select(-Date), use = 'complete.obs')
rho <- cor(rets %>% select(-Date), use = 'complete.obs')
sigma <- var(rets %>% select(-Date), use = 'complete.obs')
M <- 5 ## Number of paths
N <- 7 ## number of time steps
d <- n_stocks
t <- 1
r <- 0.05
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Brownian Motion model.
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma)
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*X0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
bls
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
PV <- CF%*%disc
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
PV
CF
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
mu<- matrix(mean_rets, ncol  = 1)
Sigma <- var(rets %>% select(-Date), use = 'complete.obs')
rho <- cor(rets %>% select(-Date), use = 'complete.obs')
sigma <- var(rets %>% select(-Date), use = 'complete.obs')
M <- 5 ## Number of paths
N <- 7 ## number of time steps
d <- n_stocks
t <- 1
r <- 0.05
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Brownian Motion model.
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma)
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*X0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
CF
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
PV
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
bls
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
rm(list = ls())
library(tidyverse)
library(Matrix)
library(plotly)
library(moments)
setwd("~/Desktop/msba/spring2021/fin_sim_comp_hedging_asset_pricing_model")
source('asset_price_model.r')
source('misc_funs.r')
source('geom_brownian_motion.r')
## Read the data ####
n_stocks <- 2
prices <- Read_Data(n_stocks)
prices %>% head()
## Calculate Returns
rets <- Returns(prices)
## Look at the moments for the prices and the returns
price_moms <- Moments(prices)
price_moms
rets_moms <- Moments(rets)
rets_moms
## GMD Model ####
mean_rets <- Single_Moment(rets_moms, 'mean') %>%
t()
mu<- matrix(mean_rets, ncol  = 1)
Sigma <- var(rets %>% select(-Date), use = 'complete.obs')
rho <- cor(rets %>% select(-Date), use = 'complete.obs')
sigma <- var(rets %>% select(-Date), use = 'complete.obs')
M <- 5 ## Number of paths
N <- 7 ## number of time steps
d <- n_stocks
t <- 1
r <- 0.05
## Strike Price listed as Last value of all stocks
K <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Unable to start at appropriate starting prices
X0 <- prices %>% select(-Date) %>% tail(1)
## Only works when start returns are at a arbritrary number
X0 <- prices %>% select(-Date) %>% tail(1) %>% t() %>% mean()
## Brownian Motion model.
gmd_model <- Geom_Brownian(M, N, n_stocks, t, mu, X0, Sigma)
X <- gmd_model$X[,,2]
deltas <- gmd_model$Delta[,,2]
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*X0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
CF
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
PV
bls <- BLS(M, N, X0, K, r, diag(Sigma)[2], t, mu )
bls
# compute performace
H.perf <- sqrt(var(PV))/bls
print(H.perf)
## Annualize Returns formula
Annualize <- function(x){
rets <- ((1 + x) ^ 365) - 1
return(rets)
}
## Formulas to find moments
Moments <- function(x){
### Find the moments
data_no_date <- x %>%
select(-Date)
summary <- data_no_date %>%
## Mean
summarize_all(mean) %>%
## Variance
bind_rows(data_no_date %>% summarize_all(sd)) %>%
## Skewness
bind_rows(data_no_date %>% summarize_all(moments::skewness)) %>%
## Kurtosis
bind_rows(data_no_date %>% summarize_all(moments::kurtosis)) %>%
##
add_column('Moments' = c('mean', 'variance', 'skewness', 'kurtosis'))
return(summary)
}
## Functions for returns
Returns <- function(prices){
## Formula for returns on stocks
Rets_Formula <- function(x){
rets <- (x - lag(x)) / lag(x)
return(rets)
}
## Prices to returns function
rets <- prices %>% select(-RF) %>%
## Apply returns, function to adjusted prices
mutate_at(vars(-Date), Rets_Formula) %>%
drop_na()
return(rets)
}
##Return single moment from Moments df
Single_Moment <- function(moments, name){
return(
moments %>%
filter(Moments == name) %>%
select(-Moments)
)
}
## Call option
ecall <- function(S){
c <- pmax(S - K, 0)
return(c)
}
## put option
eput <- function(S){
p <- pmax(K - S, 0)
return(p)
}
Delta <- function(option, S, Sh, h, t){
## Find the delta values
f0 <- option(S)
f0h <- option(Sh)
fd <-  mean(exp(-0.05 * t) * abs(f0h - f0) / h)
return(fd)
}
## function to subtract costs and discount.
Cost_Fun <- function(X, N, t, fee, discount){
## first subtract the cost of the transaction
## Then discount the net present value
price <- X * (1 - fee)
price <- price / (1 + discount)^(N * t / 260) ## time (days) * number of periods / years
return(price)
}
BLS <- function(M,N,S0,K,r,sigma,t,mu){
print(N)
d1 <- (log(S0/K) + (r + sigma*sigma/2)*t)/(sigma*sqrt(t))
d2 <- d1 - sigma*sqrt(t)
BLS <- S0*pnorm(d1) - K*exp(-r*t)*pnorm(d2)
return(BLS)
}
S0 <- 49
K <- 50
r <- 0.05
alpha <- 0.8
sigma <- 0.20*S0^(1-alpha)
t <- 20/52
mu <- 0.13
n <- 1
# 1. simulate the paths
M <- 10000
N <- 4
myCEV <- function(M,N,r,sigma,t,S0,alpha){
S.Euler <- matrix(NA,ncol=N+1,nrow=M)
S.CEV <- matrix(NA,ncol=N+1,nrow=M)
S.Euler[,1] <- S0
S.CEV[,1] <- S0
dt <- t/N
sqdt <- sqrt(dt)
for (i in 1:N){
# use a common Z to compare methods:
Z <- matrix(rnorm(M),ncol=1)
# GBM:
S.Euler[,i+1] <- S.Euler[,i] + r*S.Euler[,i]*dt +
sigma*S.Euler[,i]*sqdt*Z
# CEV:
S.CEV[,i+1] <- S.CEV[,i] + r*S.CEV[,i]*dt +
sigma*S.CEV[,i]^alpha*sqdt*Z
}
S.out <- list("GBM"=S.Euler,"CEV"=S.CEV)
return(S.out)
}
delta.hedge <- function(M,N,S0,K,r,sigma,t,mu){
print(N)
d1 <- (log(S0/K) + (r + sigma*sigma/2)*t)/(sigma*sqrt(t))
d2 <- d1 - sigma*sqrt(t)
BLS <- S0*pnorm(d1) - K*exp(-r*t)*pnorm(d2)
# Plain vanilla call payoff function
f <- function(S,K){
f <- pmax(S-K,0)
}
h <- 0.1
delta <- function(M,n,t,r,S0,K,sigma,ss=1){
set.seed(ss)
#ST <- S0*exp((r - 0.5*sigma^2)*t+sigma*sqrt(t)*rnorm(M))
ST <- myCEV(M,N,r,sigma,t,S0,alpha)$CEV[,N+1]
set.seed(ss)
#STh <- (S0+h)*exp((r - 0.5*sigma^2)*t+sigma*sqrt(t)*rnorm(M))
STh <-myCEV(M,N,r,sigma,t,S0+h,alpha)$CEV[,N+1]
f0 <- f(ST,K)
f0h <- f(STh,K)
fd <- exp(-r*t)*mean((f0h - f0) / h)
}
# Simulate the paths and deltas:
X <- deltas <- matrix(NA,ncol=N+1,nrow=M)
X[,1] <- S0
dt <- t/N
for (i in 1:N){
X[,i+1] <- X[,i]+ r*X[,i]*dt +
sigma*X[,i]^alpha*sqrt(dt)*rnorm(M)
ttm <- t - dt*(i-1)
deltas[,i] <- delta(M,n,ttm,r,X[,i],K,sigma)
}
# Fill in terminal deltas (1/0):
deltas[,N+1] <- delta(M,n,0,r,X[,N+1],K,sigma)
# Generate a matrix of positions:
CF <- matrix(NA,ncol=N+1,nrow=M)
CF[,1] <- -deltas[,1]*S0
for (i in 1:(N-1)){
CF[,i+1] <- -1*(deltas[,i+1] - deltas[,i])*X[,i+1]
}
IN <- which(X[,N+1] > K)
CF[IN,N+1] <- K - (1-deltas[IN,N])*X[IN,N+1]
CF[-IN,N+1] <- deltas[-IN,N]*X[-IN,N+1]
# 3. sum the costs:
disc <- matrix(exp(-r*seq(0,t,length=N+1)),ncol=1)
PV <- CF%*%disc
# compute performace
H.perf <- sqrt(var(PV))/BLS
print(H.perf)
outlist <- list("H.perf"=H.perf,"PV"=PV,"BLS"=BLS)
return(outlist)
}
N <- c(4,5,10,20)
H <- c(NA)
PV <- c(NA)
for (j in 1:length(N)){
tmp <- delta.hedge(M,N[j],S0,K,r,sigma,t,mu)
H[j] <- tmp$H.perf
PV[j] <- mean(tmp$PV)
}
print(H)
print(PV)
print(tmp$BLS)
print(tmp$H.perf)
sqrt(var(tmp$PV)) / tmp$BLS
